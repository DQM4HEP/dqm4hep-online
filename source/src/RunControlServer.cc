  /// \file RunControlServer.cc
/*
 *
 * RunControlServer.cc source template automatically generated by a class generator
 * Creation date : ven. oct. 27 2017
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright
 */


#include <dqm4hep/RunControlServer.h>

using namespace dqm4hep::core;
using namespace dqm4hep::net;

namespace dqm4hep {

  namespace online {

    RunControlServer::RunControlServer() :
      m_stopFlag(false),
      m_pServer(nullptr)
    {

    }

    //-------------------------------------------------------------------------------------------------

    RunControlServer::~RunControlServer()
    {
      if( m_pServer )
        delete m_pServer;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::setName(const std::string &name)
    {
      m_runControl.setName(name);
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::setPassword(const std::string &pwd)
    {
      m_runControl.setPassword(pwd);
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::run()
    {
      std::string baseName = "/dqm4hep/RunControl/" + m_runControl.name() + "/";

      m_pServer = new dqm4hep::net::Server(m_runControl.name());

      m_pSorService = m_pServer->createService(baseName + "SOR");
      m_runControl.onStartOfRun().connect(this, &RunControlServer::sor);

      m_pEorService = m_pServer->createService(baseName + "EOR");
      m_runControl.onEndOfRun().connect(this, &RunControlServer::eor);

      m_pServer->createRequestHandler(baseName + "CurrentRun", this, &RunControlServer::sendCurrentRun);

      m_pServer->start();

      while( ! m_stopFlag )
        dqm4hep::core::sleep(dqm4hep::core::TimeDuration(1));

      delete m_pServer;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::stop()
    {
      m_stopFlag = true;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::sor(dqm4hep::core::Run &run)
    {
      Json::Value jsonRun;
      run.toJson(jsonRun);

      Json::StreamWriterBuilder builder;
      builder["indentation"] = "  ";
      std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());
      std::ostringstream jsonRunStr;
      writer->write(jsonRun, &jsonRunStr);

      m_pSorService->send(jsonRunStr.str());
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::eor(const dqm4hep::core::Run &run)
    {
      Json::Value jsonRun;
      run.toJson(jsonRun);

      Json::StreamWriterBuilder builder;
      builder["indentation"] = "  ";
      std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());
      std::ostringstream jsonRunStr;
      writer->write(jsonRun, &jsonRunStr);

      m_pEorService->send(jsonRunStr.str());
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::sendCurrentRun(const Buffer &request, Buffer &response)
    {
      Json::Value jsonRun;
      m_runControl.currentRun().toJson(jsonRun);
      jsonRun["running"] = m_runControl.isRunning();

      Json::StreamWriterBuilder builder;
      builder["indentation"] = "  ";
      std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());
      std::ostringstream jsonRunStr;
      writer->write(jsonRun, &jsonRunStr);

      auto model = response.createModel<std::string>();
      std::string jsonRunStr2(jsonRunStr.str());
      model->move(std::move(jsonRunStr2));
      response.setModel(model);
    }

  }

}
